// global variable
def _GIT_COMMIT
def _GIT_COMMIT_AUTHOR
def agentLabel
def _WORKSPACE_DIR_AGENT

properties([
  buildDiscarder(
      logRotator(
          numToKeepStr: '30'
      )
  )
])

pipeline {
  agent {
    kubernetes {
        yamlFile "deployments/Jenkinsfile/gke-worker.yml"
    }
  }

  options {
    skipDefaultCheckout true
    ansiColor('xterm')
  }

  parameters {
    string(name: 'BRANCH',
      defaultValue: 'master',
      description: 'GIT BRANCH'
    )
    string(name: 'REVISION',
      defaultValue: 'HEAD',
      description: 'GIT REVISION'
    )
    choice(name: 'ACTION',
      choices: [
        'NOTSUPPORT',
        'build-and-deploy',
        'push-image',
        'deploy',
        'build-base-image'
      ],
      description: 'CHOOSE ACTION'
    )
    choice(name: 'APP_NAME',
      choices: [
        'NOTSUPPORT',
        'all',
        'api',
        'batch'
      ],
      description: 'CHOOSE APP_NAME'
    )
    choice(name: 'ENVIRONMENT',
      choices: [
        'NOTSUPPORT',
        'sit',
        'prod'
      ],
      description: 'CHOOSE ENVIRONMENT'
    )
  }

  environment {
    // define git repo info
    BRANCH                               = "${params.BRANCH}"
    REVISION                             = "${params.REVISION}"
    // define environment
    ENVIRONMENT                          = "${params.ENVIRONMENT}"
    // define action
    ACTION                               = "${params.ACTION}"
    // define workspace
    _WORKSPACE_DIR                       = "${WORKSPACE}/${BUILD_ID}"
    // add path
    PATH                                 = "${env.PATH}:/usr/local/bin:${env.HOME}/bin:/data/jenkins/bin"
  }

  stages {
    // setup environment
    stage('Setup Environment') {
      steps {
        // set env
        script {
          env._PROJECT_NAME                             = "jkos-app-svc" // project name must start with jkos- for logger
          env.DOCKER_HOST                               = "unix:///var/run/docker.sock"
          env._BUILD_ENV                                = "buildEnv"
          env._GAR_CREDENTIALS_ID                       = "jkos-sit-service_service-release_certificates"
          switch(env.ENVIRONMENT) {
            case 'sit':
              env._CONTAINER_REGISTRY                   = "asia-east1-docker.pkg.dev/jkos-sit-service/app" // to do
              env._DOCKER_IMAGE_TAG_ROOT                = "${_CONTAINER_REGISTRY}/${_PROJECT_NAME}/${ENVIRONMENT}"
              // app
              env._GIT_REPO                             = "https://gitlab.jkos.app/rd4/jkos-app-svc.git" // git repo
              // container
              env._PROFILE                              = "sit"
              env._ENVIRONMENT                          = "sit"
              env._DEVELOPER                            = "rd4"
              // deployment
              env._GITLAB_CREDENTIALS                   = "release-credential"
              env._DEPLOYMENT_DIRECTORY                 = "deployments/ansible"
              env._DEPLOYMENT_INVENTORY                 = "${_DEPLOYMENT_DIRECTORY}/inventory/${ENVIRONMENT}/hosts"
              env._DEPLOYMENT_PLAYBOOK                  = "${_DEPLOYMENT_DIRECTORY}/playbook/docker_compose.yml"
              env._ANSIBLE_INSTALLATION                 = "ansible-playbook"
              env._ANSIBLE_SSH_KEY                      = "srv-deployer_id_rsa"
              env._ANSIBLE_VAULT_KEY                    = "ansible-vault"
              // health check
              env._HEALTH_CHECK_URL                     = "http://192.168.12.81:58080/actuator/health" // application health check url
              env._TRIGGER_JENKINS_SCHEME               = "" // jenkins scheme
              env._TRIGGER_JENKINS_JOB_USER             = "" // jenkins user
              env._TRIGGER_JENKINS_JOB_PASS             = "" // jenkins user token
              env._TRIGGER_JENKINS_JOB_URI              = "" // jenkins job uri
              env._TRIGGER_JENKINS_JOB_TOKEN            = "" // jenkins job token
              env._TRIGGER_JENKINS_JOB_EXECUTOR         = "" // jenkins job executor
              // skywalking
              env._SW_AGENT_COLLECTOR_BACKEND_SERVICES  = '172.16.12.129:11800'

              // slack notification
              env._SLACK_TAG_EMAIL                      = "andy.chu@jkos.com,ted.juang@jkos.com,randall.chang@jkos.com" //to do:email split by comma
              env._SLACK_API_ENDPOINT                   = "https://sit-sre.jkos.app/api/v1/slack/jenkins"
              env._SLACK_CHANNEL                        = "#jenkins-sit-rd4"
              break
            case 'prod':
              env._CONTAINER_REGISTRY                   = "asia-east1-docker.pkg.dev/jkos-sit-service/app" // to do
              env._DOCKER_IMAGE_TAG_ROOT                = "${_CONTAINER_REGISTRY}/${_PROJECT_NAME}/${ENVIRONMENT}"
              // app
              env._GIT_REPO                             = "https://gitlab.jkos.app/rd4/jkos-app-svc.git" // git repo
              // container
              env._PROFILE                              = "prod"
              env._ENVIRONMENT                          = "prod"
              env._DEVELOPER                            = "rd4"
              // deployment
              env._GITLAB_CREDENTIALS                   = "release-credential"
              env._DEPLOYMENT_DIRECTORY                 = "deployments/ansible"
              env._DEPLOYMENT_INVENTORY                 = "${_DEPLOYMENT_DIRECTORY}/inventory/${ENVIRONMENT}/hosts"
              env._DEPLOYMENT_PLAYBOOK                  = "${_DEPLOYMENT_DIRECTORY}/playbook/docker_compose.yml"
              env._ANSIBLE_INSTALLATION                 = "ansible-playbook"
              env._ANSIBLE_SSH_KEY                      = "srv-deployer_id_rsa"
              env._ANSIBLE_VAULT_KEY                    = "ansible-vault"
              // health check
              env._HEALTH_CHECK_URL                     = "http://10.59.81.2:58080/actuator/health" // application health check url
              env._TRIGGER_JENKINS_SCHEME               = "" // jenkins scheme
              env._TRIGGER_JENKINS_JOB_USER             = "" // jenkins user
              env._TRIGGER_JENKINS_JOB_PASS             = "" // jenkins user token
              env._TRIGGER_JENKINS_JOB_URI              = "" // jenkins job uri
              env._TRIGGER_JENKINS_JOB_TOKEN            = "" // jenkins job token
              env._TRIGGER_JENKINS_JOB_EXECUTOR         = "" // jenkins job executor
              // skywalking
              env._SW_AGENT_COLLECTOR_BACKEND_SERVICES = 'skywalking-grpc.jkopay.com:8080'

              // slack notification
              env._SLACK_TAG_EMAIL                      = "andy.chu@jkos.com,ted.juang@jkos.com,randall.chang@jkos.com" //to do:email split by comma
              env._SLACK_API_ENDPOINT                   = "https://sre.jkos.com/api/v1/slack/jenkins"
              env._SLACK_CHANNEL                        = "#jenkins-prod-rd4"
              break
          }
        }

        script {
          agentLabel = "slave-001"
          _WORKSPACE_DIR_AGENT = _WORKSPACE_DIR.replaceAll("/home/jenkins/agent", "/data/jenkins")
          if (ENVIRONMENT == "prod") {
            agentLabel = "slave-001"
            _WORKSPACE_DIR_AGENT = _WORKSPACE_DIR.replaceAll("/home/jenkins/agent", "/data/jenkins")
          }
        }

        // block if selected ENVIRONMENT not supported
        script {
          if (params.ENVIRONMENT == "NOTSUPPORT") {
              error('ENVIRONMENT not supported')
          }
        }

        // block if selected ACTION not supported
        script {
          if (params.ACTION == "NOTSUPPORT") {
              error('ACTION not supported')
          }
        }

        // block if selected APP_NAME not supported
        script {
          if (params.APP_NAME == "NOTSUPPORT") {
            error('APP_NAME not supported')
          }
        }

        // app env define
        script {
          _APP_LIST = [:]
          _APP_CONFIGS = [
            "api":[
                "DEPLOYMENT_HOSTS":       "api",
                "APP_WORKDIR":            "/home/automation/srv-deployer/dev/docker-compose/jkos-app-svc/api", // "/home/automation/srv-deployer/dev/docker-compose/${_PROJECT_NAME}/api"
                "DOCKERFILE_BASE_IMAGE":  "deployments/Dockerfile/api/Dockerfile-Base-Image",
                "DOCKERFILE":             "deployments/Dockerfile/api/Dockerfile",
                "BASE_IMAGE_BUILD_FROM":  "maven:3.9.0-eclipse-temurin-17", // to do
                "BASE_IMAGE_APP":         "openjdk:20-ea-17-jdk", // to do
                "BASE_IMAGE":             "${_DOCKER_IMAGE_TAG_ROOT}/api:base",
                "APP_IMAGE":              "${_DOCKER_IMAGE_TAG_ROOT}/api",
                "APP_NAME":               "api",
                "APP_PORT":               [
                                            "sit":  "58080",
                                            "uat":  "58080",
                                            "prod": "58080"
                ],
                "COMPOSE_ENV_PATH":       "${_DEPLOYMENT_DIRECTORY}/inventory/${ENVIRONMENT}/group_vars/api/files/docker-compose/envCompose.txt",
                "APP_NETWORK":            "${_PROJECT_NAME}-api-${ENVIRONMENT}"
            ],
            'batch': [
                "DEPLOYMENT_HOSTS":       "batch",
                "APP_WORKDIR":            "/home/automation/srv-deployer/dev/docker-compose/${_PROJECT_NAME}/batch",
                "DOCKERFILE_BASE_IMAGE":  "deployments/Dockerfile/batch/Dockerfile-Base-Image", // todo if multi dockerfile
                "DOCKERFILE":             "deployments/Dockerfile/batch/Dockerfile", // todo if multi dockerfile
                "BASE_IMAGE_BUILD_FROM":  "maven:3.9.0-eclipse-temurin-17", // to do
                "BASE_IMAGE_APP":         "openjdk:20-ea-17-jdk", // to do
                "BASE_IMAGE":             "${_DOCKER_IMAGE_TAG_ROOT}/batch:base",
                "APP_IMAGE":              "${_DOCKER_IMAGE_TAG_ROOT}/batch",
                "APP_NAME":               "batch",
                "APP_PORT":               [
                                            "sit":  "58080",
                                            "uat":  "58080",
                                            "prod": "58080"
                ],
                "COMPOSE_ENV_PATH":       "${_DEPLOYMENT_DIRECTORY}/inventory/${ENVIRONMENT}/group_vars/batch/files/docker-compose/envCompose.txt",
                "APP_NETWORK":            "${_PROJECT_NAME}-batch-${ENVIRONMENT}"
            ]
          ]
          switch(params.APP_NAME) {
            case 'all':
              _APP_LIST.put("api", _APP_CONFIGS["api"])
              _APP_LIST.put("batch", _APP_CONFIGS["batch"])
              break;
            case 'api':
              _APP_LIST.put("api", _APP_CONFIGS["api"])
              break
            case 'batch':
              _APP_LIST.put("batch", _APP_CONFIGS["batch"])
          }
        }

        // git repo info
        sh(
          label:  "Git Repo: ${_GIT_REPO}",
          script: "echo Git Repo: ${_GIT_REPO}"
        )
        sh(
          label:  "Branch: ${BRANCH}",
          script: "echo Branch: ${BRANCH}"
        )
        sh(
          label:  "Revision: ${REVISION}",
          script: "echo Revision: ${REVISION}"
        )
        // environment
        sh(
          label:  "Environment: ${ENVIRONMENT}",
          script: "echo Environment: ${ENVIRONMENT}"
        )
        // action
        sh(
          label:  "Action: ${ACTION}",
          script: "echo Action: ${ACTION}"
        )
        // workspace
        sh(
          label:  "Workspace: ${_WORKSPACE_DIR_AGENT}",
          script: "echo Action: ${_WORKSPACE_DIR_AGENT}"
        )
      }
    }
    // end of setup environment

    // login Artifact Registry
    stage('login Artifact Registry') {
      when {
        allOf {
          expression {
            params.ACTION == 'push-image' || params.ACTION == 'build-base-image' || params.ACTION == 'build-and-deploy';
          }
        }
      }
      steps {
        withCredentials([file(credentialsId: env._GAR_CREDENTIALS_ID, variable: '_CERTIFICATE')]) {
          container('docker') {
            sh """
              cat ${_CERTIFICATE} | docker login -u _json_key --password-stdin https://asia-east1-docker.pkg.dev
            """
          }
        }
      }
    }
    //end of login Artifact Registry

    // git checkout
    stage('Git checkout') {
      when {
        allOf {
          expression {
            params.ACTION == 'push-image' || params.ACTION == 'build-base-image' || params.ACTION == 'build-and-deploy';
          }
        }
      }
      steps {
        container('docker') {
          git url: "${_GIT_REPO}",
              credentialsId: "${_GITLAB_CREDENTIALS}",
              branch: "${BRANCH}"
        }

        container('docker') {
          sh(
            label:  "git checkout ${REVISION}",
            script: """
              git config --global --add safe.directory "*"
              git checkout ${REVISION}
            """
          )
        }

        // get git commit
        container('docker') {
          script {
            _GIT_COMMIT = sh(
              script: """git rev-parse HEAD""",
              returnStdout: true
            ).trim()
            env._GIT_COMMIT = _GIT_COMMIT
          }
          script {
            _GIT_COMMIT_AUTHOR = sh(
              script: """git show -s --format='%ae' ${env._GIT_COMMIT}""",
              returnStdout: true
            ).trim()
            env._GIT_COMMIT_AUTHOR = _GIT_COMMIT_AUTHOR.split("@")[0]
          }
          echo "+++" + env._GIT_COMMIT_AUTHOR
        }
      }
    }
    // end of git checkout

    // docker buildx create
    stage('docker buildx create') {
      when {
        allOf {
          expression {
            params.ACTION == 'push-image' || params.ACTION == 'build-base-image' || params.ACTION == 'build-and-deploy';
          }
        }
      }
      steps {
        container('docker') {
          sh """
            docker buildx create --driver docker-container --platform linux/arm,linux/arm64,linux/amd64 --name ${_BUILD_ENV}
          """
        }
      }
    }
    //end of docker buildx create

    // build base image
    stage('Build Base Image') {
      when {
        allOf {
          expression {
            params.ACTION == 'build-base-image';
          }
        }
      }
      steps {
        script {
          def jobs = [:]
          _APP_LIST.each { key, val ->
            def job = "${key}"
            jobs[job] = {
              stage(job) {
                stage("Build ${job}") {
                  container('docker') {
                    sh(
                      label: "make build-base-image: ${val["APP_NAME"]}",
                      script: """
                        export _DOCKERFILE_BASE_IMAGE="${val["DOCKERFILE_BASE_IMAGE"]}"
                        export _BASE_IMAGE_BUILD_FROM="${val["BASE_IMAGE_BUILD_FROM"]}"
                        export _BASE_IMAGE="${val["BASE_IMAGE"]}"
                        export _APP_NAME="${val["APP_NAME"]}"
                        make build-base-image
                      """
                    )
                  }
                }
              }
            }
          }
          parallel jobs
        }
      }
    }
    // end of build base image

    // build application
    stage('Build Application') {
      when {
        allOf {
          expression {
            params.ACTION == 'push-image' || params.ACTION == 'build-and-deploy';
          }
        }
      }
      steps {
        script {
          def jobs = [:]
          _APP_LIST.each { key, val ->
            def job = "${key}"
            jobs[job] = {
              stage(job) {
                stage("Build ${job}") {
                  container('docker') {
                    sh(
                      label: "make push-image: ${val["APP_NAME"]}",
                      script: """
                        export _DOCKERFILE="${val["DOCKERFILE"]}"
                        export _BASE_IMAGE="${val["BASE_IMAGE"]}"
                        export _BASE_IMAGE_APP="${val["BASE_IMAGE_APP"]}"
                        export _APP_NAME="${val["APP_NAME"]}"
                        export _APP_IMAGE="${val["APP_IMAGE"]}"
                        make push-image
                      """
                    )
                  }
                }
              }
            }
          }
          parallel jobs
        }
      }
    }
    // end of build application

    // git checkout for deploy
    stage('Git checkout for deploy') {
      agent {
        label agentLabel
      }
      when {
        allOf {
          expression {
            params.ACTION == 'deploy' || params.ACTION == 'build-and-deploy';
          }
        }
      }
      steps {
        dir(_WORKSPACE_DIR_AGENT) {
          git url: "${_GIT_REPO}",
              credentialsId: "${_GITLAB_CREDENTIALS}",
              branch: "${BRANCH}"
        }

        dir(_WORKSPACE_DIR_AGENT) {
          sh(
            label:  "git checkout ${REVISION}",
            script: "git checkout ${REVISION}"
          )
        }

        // get git commit
        dir(_WORKSPACE_DIR_AGENT) {
          script {
            _GIT_COMMIT = sh(
              script: """git rev-parse HEAD""",
              returnStdout: true
            ).trim()
            env._GIT_COMMIT = _GIT_COMMIT
          }
          script {
            _GIT_COMMIT_AUTHOR = sh(
              script: """git show -s --format='%ae' ${env._GIT_COMMIT}""",
              returnStdout: true
            ).trim()
            env._GIT_COMMIT_AUTHOR = _GIT_COMMIT_AUTHOR.split("@")[0]
          }
          echo "+++" + env._GIT_COMMIT_AUTHOR
        }
      }
    }
    // end of git checkout for deploy

    // generator environment
    stage('Generator Environment') {
      agent {
        label agentLabel
      }
      when {
        allOf {
          expression {
            params.ACTION == 'deploy' || params.ACTION == 'build-and-deploy';
          }
        }
      }
      steps {
        script {
          def jobs = [:]
          _APP_LIST.each { key, val ->
            def job = "${key}"
            jobs[job] = {
              stage(job) {
                stage("Deploy: ${job}") {
                  dir(_WORKSPACE_DIR_AGENT) {
                    script {
                      // env compose
                      env._APP_PORT          = "${val["APP_PORT"][ENVIRONMENT]}"
                      env._APP_NETWORK       = "${val["APP_NETWORK"]}"
                      env._APP_IMAGE         = "${val["APP_IMAGE"]}"
                      env._APP_NAME          = "${val["APP_NAME"]}"
                      env._COMPOSE_ENV_PATH  = "${val["COMPOSE_ENV_PATH"]}"
                      sh (
                        label: "Generator Environment",
                        script: """
                          jupiter envUtils \
                            --envPath ${_COMPOSE_ENV_PATH} \
                            --kv "export _APP_IMAGE='${_APP_IMAGE}:${_GIT_COMMIT}'" \
                            --kv "export _APP_PORT='${_APP_PORT}'" \
                            --kv "export _APP_NETWORK='${_APP_NETWORK}'" \
                            --kv "export _APP_STACK='${_PROJECT_NAME}-${ENVIRONMENT}-${_APP_NAME}'"
                        """
                      )
                    }
                  }
                }
              }
            }
            parallel jobs
          }
        }
      }
    }
    // end of generator environment

    // deploy application
    stage('Deploy Application') {
      agent {
        label agentLabel
      }
      when {
        allOf {
          expression {
            params.ACTION == 'deploy' || params.ACTION == 'build-and-deploy';
          }
        }
      }
      steps {
        script {
          def jobs = [:]
          _APP_LIST.each { key, val ->
            def job = "${key}"
            jobs[job] = {
              stage(job) {
                stage("Deploy: ${job}") {
                  dir(_WORKSPACE_DIR_AGENT) {
                    script {
                      env._APP_WORKDIR           = "${val["APP_WORKDIR"]}"
                      env._DEPLOYMENT_HOSTS      = "${val["DEPLOYMENT_HOSTS"]}"
                      ansiblePlaybook(
                        installation: "${_ANSIBLE_INSTALLATION}",
                        credentialsId: "${_ANSIBLE_SSH_KEY}",
                        inventory: "${_DEPLOYMENT_INVENTORY}",
                        playbook: "${_DEPLOYMENT_PLAYBOOK}",
                        extraVars: [
                            hn: "${_DEPLOYMENT_HOSTS}",
                        ],
                        // extras: '-vvv',
                        vaultCredentialsId: "${_ANSIBLE_VAULT_KEY}",
                        hostKeyChecking: false,
                        colorized: true
                      )
                    }
                  }
                }
              }
            }
          }
          parallel jobs
        }
      }
    }
    // end of deploy application
  }

  post {
    success {
      node(agentLabel) {
        script {
          if (params.APP_NAME != "NOTSUPPORT") {
            sh(
              label:  "slack success notify to: ${env._SLACK_TAG_EMAIL}",
              script: """
                curl --location --request POST '${env._SLACK_API_ENDPOINT}' \
                  --header 'Accept: application/json' \
                  --header 'Content-Type: application/json' \
                  --connect-timeout 10 \
                  --data-raw '{
                      "env":"${ENVIRONMENT}",
                      "tag_email":"${env._SLACK_TAG_EMAIL}",
                      "slack_channel":"${_SLACK_CHANNEL}",
                      "build_status":true,
                      "job_name": "${env.JOB_NAME}",
                      "build_number": "${env.BUILD_NUMBER}",
                      "git_branch":"${env.BRANCH}",
                      "git_commit":"${_GIT_COMMIT}",
                      "build_url": "${env.BUILD_URL}",
                      "build_action": "${env.ACTION}"
                  }'
            """)
          }
        }
      }
    }
    failure {
      node(agentLabel) {
        script {
          if (params.APP_NAME != "NOTSUPPORT") {
            sh(
              label:  "slack fail notify to: ${env._SLACK_TAG_EMAIL}",
              script: """
                curl --location --request POST '${env._SLACK_API_ENDPOINT}' \
                  --header 'Accept: application/json' \
                  --header 'Content-Type: application/json' \
                  --connect-timeout 10 \
                  --data-raw '{
                      "env":"${ENVIRONMENT}",
                      "tag_email":"${env._SLACK_TAG_EMAIL}",
                      "slack_channel":"${_SLACK_CHANNEL}",
                      "build_status":false,
                      "job_name": "${env.JOB_NAME}",
                      "build_number": "${env.BUILD_NUMBER}",
                      "git_branch":"${env.BRANCH}",
                      "git_commit":"${_GIT_COMMIT}",
                      "build_url": "${env.BUILD_URL}",
                      "build_action": "${env.ACTION}"
                  }'
            """)
          }
        }
      }
    }
    /* clean up our workspace */
    always {
      node(agentLabel) {
        script {
          dir(_WORKSPACE_DIR) {
            deleteDir()
          }
        }
      }
    }
    /* end of clean up our workspace */
  }
}
